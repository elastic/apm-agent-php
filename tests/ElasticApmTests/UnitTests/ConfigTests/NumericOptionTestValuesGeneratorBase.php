<?php

/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

declare(strict_types=1);

namespace ElasticApmTests\UnitTests\ConfigTests;

use Ds\Set;
use Elastic\Apm\Impl\Config\NumericOptionParser;
use Elastic\Apm\Impl\Util\NumericUtil;
use Elastic\Apm\Impl\Util\RangeUtil;
use IteratorIterator;

/**
 * @template   T of float|int
 *
 * @implements OptionTestValuesGeneratorInterface<T>
 */
abstract class NumericOptionTestValuesGeneratorBase implements OptionTestValuesGeneratorInterface
{
    /**
     * @return NumericOptionParser<T>
     */
    abstract protected function optionParser(): NumericOptionParser;

    /**
     * @return T
     */
    abstract protected static function maxValueSupportedByType();

    /**
     * @return T
     */
    abstract protected static function minValueSupportedByType();

    /**
     * @return T
     */
    protected function effectiveMaxValidValue()
    {
        return $this->optionParser()->maxValidValue() ?? static::maxValueSupportedByType();
    }

    /**
     * @return T
     */
    protected function effectiveMinValidValue()
    {
        return $this->optionParser()->minValidValue() ?? static::minValueSupportedByType();
    }

    /**
     * @param T $value
     *
     * @return bool
     *
     */
    public function isInValidRange($value): bool
    {
        return NumericUtil::isInClosedInterval(
            $this->effectiveMinValidValue(),
            $value,
            $this->effectiveMaxValidValue()
        );
    }

    /**
     * @return iterable<OptionTestValidValue<int>>
     */
    protected function intManualInterestingValues(): iterable
    {
        yield new OptionTestValidValue('0', 0);
        yield new OptionTestValidValue('-0', 0);
        yield new OptionTestValidValue('+0', 0);

        yield new OptionTestValidValue('1', 1);
        yield new OptionTestValidValue('+1', 1);
        yield new OptionTestValidValue('-1', -1);

        yield new OptionTestValidValue('1234', 1234);
        yield new OptionTestValidValue('-56789', -56789);
    }

    /**
     * @return iterable<OptionTestValidValue<float|int>>
     * @phpstan-return iterable<OptionTestValidValue<T>>
     */
    abstract protected function manualInterestingValues(): iterable;

    /**
     * @return iterable<OptionTestValidValue<float|int>>
     * @phpstan-return iterable<OptionTestValidValue<T>>
     */
    private function autoGeneratedInterestingValues(): iterable
    {
        /**
         * @var Set<float|int>
         * @phpstan-var Set<T>
         */
        $values = new Set();

        foreach ($this->autoGeneratedInterestingValuesToDiff() as $interestingValue) {
            foreach ($this->autoGeneratedInterestingValueDiffs() as $interestingDiff) {
                if ($interestingValue <= (static::maxValueSupportedByType() - $interestingDiff)) {
                    /**
                     * @var float|int $value
                     * @phpstan-var T $value
                     */
                    $value = $interestingValue + $interestingDiff;
                    $values->add($value);
                }
                if ($interestingValue >= (static::minValueSupportedByType() + $interestingDiff)) {
                    /**
                     * @var float|int $value
                     * @phpstan-var T $value
                     */
                    $value = $interestingValue - $interestingDiff;
                    $values->add($value);
                }
            }
        }

        foreach ($values as $value) {
            yield static::createOptionTestValidValue($value);
        }
    }

    /**
     * @return iterable<OptionTestValidValue<float|int>>
     * @phpstan-return iterable<OptionTestValidValue<T>>
     */
    private function interestingValues(): iterable
    {
        yield from $this->manualInterestingValues();
        yield from $this->autoGeneratedInterestingValues();
    }

    /**
     * @param  T $min
     * @param  T $max
     *
     * @return T
     */
    abstract protected static function randomValue($min, $max);

    /**
     * @param float|int $value
     *
     * @return OptionTestValidValue<float|int>
     *
     * @phpstan-param  T $value
     * @phpstan-return OptionTestValidValue<T>
     */
    abstract protected static function createOptionTestValidValue($value);

    public function validValues(): iterable
    {
        /**
         * @var OptionTestValidValue<float|int> $candidate
         * @phpstan-var OptionTestValidValue<T> $candidate
         */
        foreach ($this->interestingValues() as $candidate) {
            if ($this->isInValidRange($candidate->parsedValue)) {
                yield $candidate;
            }
        }

        /** @noinspection PhpUnusedLocalVariableInspection */
        foreach (RangeUtil::generateUpTo(self::NUMBER_OF_RANDOM_VALUES_TO_TEST) as $_) {
            $value = static::randomValue($this->effectiveMinValidValue(), $this->effectiveMaxValidValue());
            yield static::createOptionTestValidValue($value);
        }
    }

    public function invalidRawValues(): iterable
    {
        yield from [
            '',
            ' ',
            '\t',
            '\r\n',
            'a',
            'abc',
            '123abc',
            'abc123',
            'a_123_b',
            '1a',
            '12.3abc',
            'abc1.23',
            'a_12.3_b',
            'a_12.3E+1',
            '12.3E+1_b',
        ];

        /**
         * @var OptionTestValidValue<float|int> $interestingValue
         * @phpstan-var OptionTestValidValue<T> $interestingValue
         */
        foreach ($this->autoGeneratedInterestingValues() as $interestingValue) {
            if (!$this->isInValidRange($interestingValue->parsedValue)) {
                yield $interestingValue->rawValue;
            }
        }

        if (static::minValueSupportedByType() < $this->effectiveMinValidValue()) {
            /** @noinspection PhpUnusedLocalVariableInspection */
            foreach (RangeUtil::generateUpTo(self::NUMBER_OF_RANDOM_VALUES_TO_TEST) as $_) {
                yield strval(static::randomValue(static::minValueSupportedByType(), $this->effectiveMinValidValue()));
            }
        }
        if ($this->effectiveMaxValidValue() < static::maxValueSupportedByType()) {
            /** @noinspection PhpUnusedLocalVariableInspection */
            foreach (RangeUtil::generateUpTo(self::NUMBER_OF_RANDOM_VALUES_TO_TEST) as $_) {
                yield strval(static::randomValue($this->effectiveMaxValidValue(), static::maxValueSupportedByType()));
            }
        }
    }

    /**
     * @return iterable<float|int>
     * @phpstan-return iterable<T>
     */
    abstract protected function autoGeneratedInterestingValuesToDiff(): iterable;

    /**
     * @return iterable<T>
     */
    abstract protected function autoGeneratedInterestingValueDiffs(): iterable;

    /**
     * @return iterable<int>
     */
    protected function intInterestingValuesToDiff(): iterable
    {
        /** @var Set<int> */
        $result = new Set();
        $result->add(0);

        if (is_int($this->optionParser()->minValidValue())) {
            $result->add(
                $this->optionParser()->minValidValue(),
                intdiv($this->optionParser()->minValidValue(), 2)
            );
        }
        if (is_int($this->optionParser()->maxValidValue())) {
            $result->add(
                $this->optionParser()->maxValidValue(),
                intdiv($this->optionParser()->maxValidValue(), 2)
            );
        }
        $result->add(
            PHP_INT_MIN,
            intdiv(PHP_INT_MIN, 2),
            intdiv(PHP_INT_MAX, 2),
            PHP_INT_MAX
        );

        return new IteratorIterator($result);
    }

    /**
     * @return iterable<int>
     */
    protected static function intInterestingDiffs(): iterable
    {
        yield from [0, 1, 2, 5, 10, 11, 100, 101, 123, 200, 202, 500, 1000, 9876];
    }
}
